
use std::str::FromStr;

use lalrpop_util::ParseError;

use super::ast::BinOpKind::*;
use super::ast::ScalarKind::*;
use super::ast::ExprKind::*;
use super::ast::Parameter;
use super::ast::Symbol;
use super::partial_types::*;
use super::partial_types::PartialType::*;
use super::partial_types::PartialBuilderKind::*;
use super::program::*;

grammar["LALR(1)"];

extern {
    // Source location and error types returned by this parser. 
    type Location = usize;
    type Error = &'static str;
}

// Expose the nicer function name parse_expr instead of parse_Expr.
pub expr = <Expr>;

// Expose the nicer function name parse_program instead of parse_Program.
pub program = <Program>;

Program: Program = {
    <macros:(<Macro>)*> <entry:Lambda> => Program { macros: macros, entry_point: *entry }
};

Type: Box<PartialType> = {
    "?" => Box::new(Unknown),   // Don't really need this in the grammar but it's nice for testing
    "bool" => Box::new(Scalar(Bool)),
    "i32" => Box::new(Scalar(I32)),
    "vec" "[" <t:Type> "]" => Box::new(Vector(t)),
    "appender" "[" <t:Type> "]" => Box::new(Builder(Appender(t))),
};

Macro: Macro = {
    "macro" <n:Name> "(" <p:CommaSep<Name>> ")" "=" <e:SumExpr> => {
        Macro { name: n, parameters: p, body: *e }
    }
};

Expr: Box<PartialExpr> = {
    Lambda,
    LetExpr
};

Lambda: Box<PartialExpr> = {
    "|" <p:CommaSep<Parameter>> "|" <e:Expr> => expr_box(Lambda(p, e))
};

Parameter: PartialParameter = {
    <n:Name> <t:(":" <Type>)?> => Parameter { name: n, ty: t.map(|b| *b).unwrap_or(Unknown) }
};

LetExpr: Box<PartialExpr> = {
    "let" <s:Name> <t:(":" <Type>)?> "=" <value:SumExpr> ";" <body:Expr> => {
        let mut res = expr_box(Let(s, value, body));
        if let Some(t) = t {
            res.ty = *t;
        }
        res
    },
    SumExpr
};

SumExpr: Box<PartialExpr> = {
    <l:SumExpr> "+" <r:AscribeExpr> => expr_box(BinOp(Add, l, r)),
    <l:SumExpr> "-" <r:AscribeExpr> => expr_box(BinOp(Subtract, l, r)),
    ApplyExpr
};

ApplyExpr: Box<PartialExpr> = {
    <f:Term> "(" <p:CommaSep<Expr>> ")" =>
        expr_box(Apply(f, p.into_iter().map(|b| *b).collect())),
    <AscribeExpr>
};

AscribeExpr: Box<PartialExpr> = {
    <term:Term> ":" <ty:Type> => {
        let mut term = term;
        term.ty = *ty;
        term
    },
    <Term>
};

Term: Box<PartialExpr> = {
    BoolLiteral,
    I32Literal,
    Ident,
    MakeVector,
    Map,
    NewBuilder,
    Merge,
    For,
    "(" <Expr> ")"
};

BoolLiteral: Box<PartialExpr> = {
    "true" => expr_box(BoolLiteral(true)),
    "false" => expr_box(BoolLiteral(false)),
};

I32Literal: Box<PartialExpr> = {
    <s:r"[0-9]+"> =>? {
       match i32::from_str(s) {
           Ok(v) => Ok(expr_box(I32Literal(v))),
           Err(_) => Err(ParseError::User { error: "bad i32 literal" })
           // TODO: This won't work for -2**31 
       }
    }
};

Ident: Box<PartialExpr> = {
    <n:Name> => expr_box(Ident(n))
};

MakeVector: Box<PartialExpr> = {
    "[" <v:CommaSep<Expr>> "]" => {
        let v: Vec<PartialExpr> = v.into_iter().map(|b| *b).collect();
        expr_box(MakeVector(v))
    }
};

Map: Box<PartialExpr> = {
   "map" "(" <d:Expr> "," <f:Expr> ")" => expr_box(Map(d, f))
};

NewBuilder: Box<PartialExpr> = {
    "appender" <t:("[" <Type> "]")?> => {
        Box::new(PartialExpr {
            kind: NewBuilder,
            ty: Builder(Appender(t.unwrap_or(Box::new(Unknown))))
        })
    }
};

Merge: Box<PartialExpr> = {
   "merge" "(" <b:Expr> "," <v:Expr> ")" => expr_box(Merge(b, v))
};

For: Box<PartialExpr> = {
   "for" "(" <d:Expr> "," <b:Expr> "," <f:Expr> ")" => expr_box(For(d, b, f))
};

Name: Symbol = <s:r"[A-Za-z_][A_Za-z0-9_]*"> => s.to_string();

// Helper macro to read a comma-separated list 
CommaSep<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};